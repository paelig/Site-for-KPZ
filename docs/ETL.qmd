---
title: "Функции ETL"
---

# github_api_get
``` R
github_api_get <- function(url) {
  # обработка запросов по URL к GitHub API
  if (nzchar(GITHUB_TOKEN)) {
    response <- GET(url, add_headers(Authorization = paste("token", GITHUB_TOKEN)))
  } else {
    flog.warn("[WARN] No token provided")
    response <- GET(url)
  }
  ...
  return(response)
}
```

Функция отправляет HTTP-запросы к GitHub API с обработкой авторизации и основных ошибок. Поддерживает использование персонального токена для увеличения лимита запросов. Автоматически использует токен из глобальной переменной GITHUB_TOKEN, если она установлена.

## Особенности

- Логирует все предупреждения и ошибки через flog
- Для запросов использует пакет httr (функции GET и add_headers)
- При отсутствии токена выводит предупреждение, но продолжает выполнение

## Входные данные

- url - URL-адрес для запроса к GitHub API (строка)

## Выходные данные

- response - объект ответа от httr при успешном запросе (код 200)
- NULL - для следующих кодов состояния:
    - 204 (No Content) - репозиторий не содержит данных
    - 404 (Not Found) - пользователь/репозиторий не найден
    - 409 (Conflict) - репозиторий пустой
    - 5xx (Server errors) - ошибки сервера GitHub
- gрерывает выполнение с ошибкой (stop()) для:
    - 401 (Unauthorized) - неверный/просроченный токен
    - 403 (Forbidden) - лимит запросов исчерпан
    - Все другие необработанные коды ошибок (кроме 200)
    
# get_user_commits_df
``` R
get_user_commits_df <- function(repos, setProgress = NULL, batch_size = 200, log_file = 'logs.log'){
  ...
  return(commits_df)
}

``` 
Функция для комплексной обработки коммитов GitHub с расширенными возможностями кэширования в DuckDB, поддержкой пакетной обработки и детальным логированием.

## Особенности
- Полноценная работа с ветками - обрабатывает коммиты во всех ветках каждого репозитория
- Интеллектуальное кэширование:
    - Автоматически создает и использует индексованную таблицу в DuckDB
    - Пропускает уже обработанные коммиты (по SHA)
    - Пакетная запись данных (оптимизация производительности)
- Расширенное отслеживание прогресса:
    - Двухэтапный процесс (сбор SHA + детальная обработка)
    - Расчет оставшегося времени выполнения
    - Надежная обработка ошибок с детальным логированием

## Входные данные 
- repos	- список репозиториев из get_user_repos()
- setProgress	- функция для обновления прогресса (опционально)
- batch_size - размер пакета для записи в БД (по умолчанию 200)
- log_file - файл для записи логов (по умолчанию 'logs.log')

## Выходные данные:
- commits_df - датафрейм со структурой:
    - id - SHA коммита
    - patch - Diff-патч или "NULL"
    - repo -  полное имя репозитория (owner/repo)
    - author - имя автора коммита
    - date - дата в формате "ГГГГ.ММ.ДД ЧЧ:ММ:СС" (локальное время)
    - filename - путь к файлу
    - status - статус изменения (added/modified/removed)
    - additions - добавленные строки
    - deletions - удаленные строки
    - changes - общее количество изменений
    - message - сообщение коммита
    - branch - название ветки

## Детали реализации
### 1. Подготовка БД:
- Автоматическое создание таблицы и индекса при первом запуске
- Использование переменных окружения (DUCK_DB, COMMITS_TABLE)

### 2. Процесс обработки:
- Этап 1: Сбор всех SHA коммитов (по всем веткам)
- Этап 2: Пакетная обработка новых коммитов
- Пропуск существующих записей (по SHA)

### 3. Оптимизации:
- Пакетная запись в БД (контролируется batch_size)
- Локальное кэширование SHA для минимизации запросов к БД
- Преобразование времени в локальный часовой пояс

### 4. Логирование:
- Запись в файл логов (по умолчанию 'logs.log')
- Разные уровни детализации (INFO, DEBUG, TRACE)

# get_user_repos

``` R
get_user_repos <- function(username, setProgress) {
  ...
  return(repo_data)
} 
```

Функция получает полный список репозиториев пользователя GitHub с расширенной метаинформацией, включая данные о контрибьюторах, с детальным отслеживанием прогресса.

## Особенности
- Автоматически обрабатывает все страницы результатов (до 100 репозиториев на страницу)
- Определяет общее количество страниц из заголовка Link при первом запросе
- Два этапа отслеживания: получение и обработка репозиториев
- Расчёт оставшегося времени в формате HH:MM:SS
- Для каждого репозитория выполняется отдельный запрос для получения количества контрибьюторов
- Возвращает NULL если репозитории не найдены
- Пропускает битые репозитории без остановки выполнения

## Входные данные

- username - имя пользователя GitHub (обязательный)
- setProgress - функция для обновления прогресс-бара (обязательный), должна поддерживать:
    - message - основной текст статуса
    - value - текущий прогресс (0-1)
    - detail - детализация (количество/время)

## Выходные данные
- repo_data - список с данными о каждом репозитории, содержащий:
    - username - логин владельца
    - avatar - URL аватара владельца
    - name - название репозитория
    - full_name - полное имя (user/repo)
    - description - описание или "Нет описания"
    - language - основной язык или "Не указан"
    - stars - количество звёзд
    - forks - количество форков
    - created_at, updated_at - даты в POSIXct
    - url - HTML-ссылка на репозиторий
    - open_issues - количество открытых issues
    - contributors - число контрибьюторов
    - is_fork - логическое значение (TRUE/FALSE)
    - license - название лицензии или "Нет лицензии"
    - size - размер в KB

# get_user_profile

``` R
get_user_profile <- function(username) {
  ...
  return(profile_data)
 } 
```

Функция получает и структурирует основную информацию о профиле пользователя GitHub через API.

## Особенности
- Компактная реализация с обработкой NULL-значений
- Автоматическая подстановка значений по умолчанию для пустых полей
- Возвращает готовую структуру для отображения профиля
- Интеграция с github_api_get для обработки ошибок API

## Входные данные
- username - логин пользователя GitHub

## Выходные данные
- profile_data
    - name - логин пользователя
    - bio - биография или "Биография не указана"
    - avatar_url - URL аватара
    - created_at - дата создания аккаунта (ISO 8601)
    - updated_at - дата обновления профиля
    - company - название компании или NULL
    - location - город/страна или NULL
    - followers - количество подписчиков
    - following - количество подписок
    - public_repos - количество публичных репозиториев
    - html_url - ссылка на профиль
    - blog - URL блога/сайта или NULL
- NULL если: 
    - пользователь не найден (404)
    - ошибка доступа к API
    - неверный формат ответа
    
# prepare_activity_data

``` R
prepare_activity_data <- function(repos) {
  ...
  return(activity_data)
}
```

Функция преобразует данные о репозиториях GitHub в структурированный формат для визуализации активности (issues и forks) по временной шкале.

## Особенности
- Создает "длинный" формат данных, подходящий для построения временных графиков
- Разделяет данные на два типа активности: Issues и Forks
- Автоматически фильтрует NULL-входные данные
- Преобразует даты в формат Date для удобства визуализации

## Входные данные
- repos - список репозиториев, полученный из get_user_repos(). Каждый элемент должен содержать:
    - created_at - дата создания репозитория (в формате, конвертируемом в Date)
    - updated_at - дата последнего обновления репозитория
    - open_issues - количество открытых issues (числовое)
    - forks - количество форков (числовое)

## Выходные данные:
- activity_data - датафрейм в "длинном" формате с колонками:
    - date - Дата (тип Date)
    - count - Числовое значение:
        - Для типа "Issues" - количество открытых issues
        - Для типа "Forks" - количество форков
    - type - Тип активности (фактор с уровнями "Issues" и "Forks")

## Логика работы

1. Для Issues использует:
    - Дату создания репозитория (created_at)
    - Количество открытых issues (open_issues)
2. Для Forks использует:
    - Дату последнего обновления (updated_at)
    - Количество форков (forks)
3. Объединяет оба типа активности в один датафрейм

# prepare_language_data
``` R
prepare_language_data <- function(repos) {
  ...
  return(language_data)
}
```
Функция анализирует языковую статистику по списку репозиториев GitHub, создавая агрегированный отчет о частоте использования языков программирования.

## Особенности
- Фильтрация данных - автоматически игнорирует репозитории без указанного языка
- Агрегация - группирует одинаковые языки и подсчитывает количество репозиториев
- Простота - минимальная обработка данных для последующей визуализации

## Входные данные
- repos - список репозиториев (результат get_user_repos()), где каждый элемент должен содержать:
    - language - название языка программирования (строка) или NULL

Выходные данные:
- language_data - датафрейм с двумя столбцами:
    - language - название языка программирования
    - count - количество репозиториев на этом языке

## Алгоритм работы
1. Фильтрация:
    - Отбрасывает репозитории с language = NULL
    - Игнорирует пустые/неопределенные значения
2. Преобразование:
    - Создает промежуточный датафрейм с 1 строкой на каждый язык каждого репозитория
    - Присваивает значение count = 1 для каждого случая
3. Агрегация:
    - Группирует данные по названию языка
    - Суммирует количество репозиториев для каждого языка
    
# prepare_commit_heatmap_data
``` R
prepare_commit_heatmap_data <- function(commits) {
  ...
  return(heatmap_data)
}
``` 

Функция преобразует данные о коммитах в формат, оптимальный для построения тепловой карты активности по дням недели и часам.

## Особенности
- Поддержка русского языка - использует русские названия дней недели
- Дубликаты - автоматически удаляет повторяющиеся коммиты по полю id
- Часовые пояса - корректно работает с UTC временем
- Гибкая группировка - агрегирует данные по часам и дням недели

## Входные данные
- commits - датафрейм с коммитами (результат get_user_commits_df()), должен содержать:
    - id - уникальный идентификатор коммита
    - date - дата в формате "ГГГГ.ММ.ДД ЧЧ:ММ" (UTC)

## Выходные данные
- heatmap_data - датафрейм с тремя столбцами:
    - hour - час дня (0-23)
    - day - день недели
    - count - количество коммитов
    
## Алгоритм обработки
1. Фильтрация данных:
    - Удаление дубликатов по id
    - Конвертация даты в POSIXct (UTC)
    - Удаление записей с NA в дате
2. Извлечение признаков:
    - День недели (на русском, фактор с правильным порядком уровней)
    - Час дня (0-23)
3. Агрегация:
    - Группировка по часам и дням недели
    - Подсчёт количества коммитов в каждой группе